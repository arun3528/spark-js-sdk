/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/* eslint camelcase: [0] */

import url from 'url';

import {assert} from '@webex/test-helper-chai';
import {browserOnly} from '@webex/test-helper-mocha';
import sinon from '@ciscospark/test-helper-sinon';
import MockSpark from '@ciscospark/test-helper-mock-spark';
import {Credentials} from '@webex/webex-core';
import Authorization from '@webex/plugin-authorization-browser-first-party';
import {base64, patterns} from '@webex/common';
import {merge} from 'lodash';

browserOnly(describe)('plugin-authorization-browser-first-party', () => {
  describe('Authorization', () => {
    function makeSpark(href = 'https://example.com', csrfToken = undefined, config = {}) {
      const mockWindow = {
        history: {
          replaceState(a, b, location) {
            mockWindow.location.href = location;
          }
        },
        location: {
          href
        },
        sessionStorage: {
          getItem: sinon.stub().returns(csrfToken),
          removeItem: sinon.spy(),
          setItem: sinon.spy()
        }
      };

      sinon.spy(mockWindow.history, 'replaceState');

      const spark = new MockSpark({
        children: {
          authorization: Authorization,
          credentials: Credentials
        },
        request: sinon.stub().returns(Promise.resolve({body: {access_token: 'AT', token_type: 'Fake', refresh_token: 'RT'}})),
        config: merge({
          credentials: {
            idbroker: {
              url: process.env.IDBROKER_BASE_URL,
              defaultUrl: process.env.IDBROKER_BASE_URL
            },
            identity: {
              url: process.env.IDENTITY_BASE_URL,
              defaultUrl: process.env.IDENTITY_BASE_URL
            },
            activationUrl: `${process.env.IDBROKER_BASE_URL || 'https://idbroker.webex.com'}/idb/token/v1/actions/UserActivation/invoke`,
            authorizeUrl: `${process.env.IDBROKER_BASE_URL || 'https://idbroker.webex.com'}/idb/oauth2/v1/authorize`,
            setPasswordUrl: `${process.env.IDBROKER_BASE_URL || 'https://identity.webex.com'}/identity/scim/v1/Users`,
            logoutUrl: `${process.env.IDBROKER_BASE_URL || 'https://idbroker.webex.com'}/idb/oauth2/v1/logout`,
            // eslint-disable-next-line camelcase
            client_id: 'fake',
            // eslint-disable-next-line camelcase
            client_secret: 'fake',
            // eslint-disable-next-line camelcase
            redirect_uri: 'http://example.com',
            // eslint-disable-next-line camelcase
            scope: 'scope:one',
            refreshCallback: () => Promise.resolve()
          }
        }, config),
        getWindow() {
          return mockWindow;
        }
      });

      return spark;
    }

    describe('#initialize()', () => {
      describe('when there is a code in the url', () => {
        it('exchanges it for an access token and sets ready', () => {
          const spark = makeSpark('http://example.com/?code=5');

          assert.isFalse(spark.authorization.ready);
          assert.isFalse(spark.credentials.canAuthorize);

          return spark.authorization.when('change:ready')
            .then(() => {
              assert.calledOnce(spark.request);
              assert.isTrue(spark.authorization.ready);
              assert.isTrue(spark.credentials.canAuthorize);
            });
        });

        it('validates the csrf token', () => {
          const csrfToken = 'abcd';

          assert.throws(() => {
            // eslint-disable-next-line no-unused-vars
            const spark = makeSpark(`http://example.com/?code=5&state=${base64.encode(JSON.stringify({csrf_token: 'someothertoken'}))}`, csrfToken);
          }, /CSRF token someothertoken does not match stored token abcd/);

          assert.throws(() => {
            // eslint-disable-next-line no-unused-vars
            const spark = makeSpark(`http://example.com/?code=5&state=${base64.encode(JSON.stringify({}))}`, csrfToken);
          }, /Expected CSRF token abcd, but not found in redirect query/);

          assert.throws(() => {
            // eslint-disable-next-line no-unused-vars
            const spark = makeSpark('http://example.com/?code=5', csrfToken);
          }, /Expected CSRF token abcd, but not found in redirect query/);

          const spark = makeSpark(`http://example.com/?code=5&state=${base64.encode(JSON.stringify({csrf_token: csrfToken}))}`, csrfToken);

          return spark.authorization.when('change:ready')
            .then(() => {
              assert.isTrue(spark.credentials.canAuthorize);
              assert.called(spark.getWindow().sessionStorage.removeItem);
            });
        });

        it('removes the oauth parameters from the url', () => {
          const csrfToken = 'abcd';

          const spark = makeSpark(`http://example.com/?code=5&state=${base64.encode(JSON.stringify({csrf_token: csrfToken, something: true}))}`, csrfToken);

          return spark.authorization.when('change:ready')
            .then(() => {
              assert.isTrue(spark.credentials.canAuthorize);
              assert.called(spark.getWindow().sessionStorage.removeItem);
              assert.called(spark.getWindow().history.replaceState);
              assert.equal(spark.getWindow().location.href, `http://example.com/?state=${base64.encode(JSON.stringify({something: true}))}`);
            });
        });
      });
      describe('when the url contains an error', () => {
        it('throws a grant error', () => {
          assert.throws(() => {
            makeSpark('http://127.0.0.1:8000/?error=invalid_scope&error_description=The%20requested%20scope%20is%20invalid.');
          }, /The requested scope is invalid./);
        });
      });

      describe('when there is nothing in the url', () => {
        it('sets ready', () => {
          const spark = makeSpark('http://example.com');

          assert.isTrue(spark.authorization.ready);
          assert.isFalse(spark.credentials.canAuthorize);
        });
      });

      it('when the url state contains CI info', () => {
        const spark = makeSpark(`http://example.com/?code=5&state=${base64.encode(JSON.stringify({idbroker: 'newIdBroker', identity: 'newIdentity'}))}`);

        return spark.authorization.when('change:ready')
          .then(() => {
            assert.equal(spark.config.credentials.idbroker.url, 'newIdBroker');
            assert.equal(spark.config.credentials.identity.url, 'newIdentity');
          });
      });
    });

    describe('#initiateLogin()', () => {
      it('calls #initiateAuthorizationCodeGrant()', () => {
        const spark = makeSpark(undefined, undefined, {
          credentials: {
            clientType: 'confidential'
          }
        });

        sinon.spy(spark.authorization, 'initiateAuthorizationCodeGrant');

        return spark.authorization.initiateLogin()
          .then(() => {
            assert.called(spark.authorization.initiateAuthorizationCodeGrant);
            assert.include(spark.getWindow().location, 'response_type=code');
          });
      });

      it('puts CI info in state for #initiateAuthorizationCodeGrant() when non-default CI', () => {
        const spark = makeSpark(`http://example.com/?code=5&state=${base64.encode(JSON.stringify({csrf_token: 'csrf_token'}))}`, 'csrf_token');

        spark.config.credentials.idbroker.url = 'notDefaultIdBroker';
        spark.config.credentials.identity.url = 'notDefaultIdBroker';

        const spy = sinon.spy(spark.authorization, 'initiateAuthorizationCodeGrant');

        return spark.authorization.initiateLogin()
          .then(() => {
            assert.calledWith(spy, sinon.match.has('state', sinon.match.has('idbroker', 'notDefaultIdBroker', 'identity', 'notDefaultIdBroker')));
          });
      });

      it('does not put CI info in state for #initiateAuthorizationCodeGrant() when default CI', () => {
        const spark = makeSpark(`http://example.com/?code=5&state=${base64.encode(JSON.stringify({csrf_token: 'csrf_token'}))}`, 'csrf_token');

        const spy = sinon.spy(spark.authorization, 'initiateAuthorizationCodeGrant');

        return spark.authorization.initiateLogin()
          .then(() => {
            assert.neverCalledWith(spy, sinon.match.has('state', sinon.match.has('idbroker', 'notDefaultIdBroker', 'identity', 'notDefaultIdBroker')));
          });
      });

      it('adds a csrf_token to the login url and sessionStorage', () => {
        const spark = makeSpark(undefined, undefined, {
          credentials: {
            clientType: 'confidential'
          }
        });

        sinon.spy(spark.authorization, 'initiateAuthorizationCodeGrant');

        return spark.authorization.initiateLogin()
          .then(() => {
            assert.called(spark.authorization.initiateAuthorizationCodeGrant);
            assert.include(spark.getWindow().location, 'response_type=code');
            const {query} = url.parse(spark.getWindow().location, true);
            let {state} = query;

            state = JSON.parse(base64.decode(state));
            assert.property(state, 'csrf_token');
            assert.isDefined(state.csrf_token);
            assert.match(state.csrf_token, patterns.uuid);
            assert.called(spark.getWindow().sessionStorage.setItem);
            assert.calledWith(spark.getWindow().sessionStorage.setItem, 'oauth2-csrf-token', state.csrf_token);
          });
      });

      it('sets #isAuthorizing', () => {
        const spark = makeSpark(undefined, undefined, {
          credentials: {
            clientType: 'confidential'
          }
        });

        assert.isFalse(spark.authorization.isAuthorizing);
        const p = spark.authorization.initiateLogin();

        assert.isTrue(spark.authorization.isAuthorizing);

        return p.then(() => assert.isFalse(spark.authorization.isAuthorizing));
      });

      it('sets #isAuthenticating', () => {
        const spark = makeSpark(undefined, undefined, {
          credentials: {
            clientType: 'confidential'
          }
        });

        assert.isFalse(spark.authorization.isAuthenticating);
        const p = spark.authorization.initiateLogin();

        assert.isTrue(spark.authorization.isAuthenticating);

        return p.then(() => assert.isFalse(spark.authorization.isAuthenticating));
      });
    });

    describe('#initiateAuthorizationCodeGrant()', () => {
      it('redirects to the login page with response_type=code', () => {
        const spark = makeSpark(undefined, undefined, {
          credentials: {
            clientType: 'confidential'
          }
        });

        sinon.spy(spark.authorization, 'initiateAuthorizationCodeGrant');

        return spark.authorization.initiateLogin()
          .then(() => {
            assert.called(spark.authorization.initiateAuthorizationCodeGrant);
            assert.include(spark.getWindow().location, 'response_type=code');
          });
      });
    });

    describe('#_cleanUrl()', () => {
      it('removes the state parameter when it has no keys', () => {
        const spark = makeSpark(undefined, undefined, {
          credentials: {
            clientType: 'confidential'
          }
        });
        const location = {
          query: {
            code: 'code',
            state: {
              csrf_token: 'token'
            }
          }
        };

        sinon.spy(spark.authorization, '_cleanUrl');
        spark.authorization._cleanUrl(location);
        assert.called(spark.getWindow().history.replaceState);
        assert.equal(spark.getWindow().location.href, '');
      });

      it('keeps the parameter when it has keys', () => {
        const spark = makeSpark(undefined, undefined, {
          credentials: {
            clientType: 'confidential'
          }
        });
        const location = {
          query: {
            code: 'code',
            state: {
              csrf_token: 'token',
              key: 'value'
            }
          }
        };

        sinon.spy(spark.authorization, '_cleanUrl');
        spark.authorization._cleanUrl(location);
        assert.called(spark.getWindow().history.replaceState);
        const {href} = spark.getWindow().location;

        assert.isDefined(href);
        assert.equal(href, `?state=${base64.encode(JSON.stringify({key: 'value'}))}`);
        assert.notInclude(href, 'csrf_token');
      });
    });
  });
});

import {StatelessSparkPlugin} from '@ciscospark/spark-core';
import {isFunction, isBoolean} from 'lodash';
import {uuid} from 'uuid';

import {
  MEETINGS,
  STATS,
  EVENTS
} from '../constants';
import StatsHistory from '../stats/history';
import StatsStream from '../stats/stream';
import StatsFilter from '../stats/filter';
import StatsEvents from '../stats/events';
import StatsAnalyzer from '../stats/analyzer';

/**
 * @class MeetingStats
 */
export default class MeetingStats extends StatelessSparkPlugin {
  namespace = MEETINGS;

  /**
   * @param {Object} attrs
   * @param {Object} options
   * @param {Object} optionalCreateOptions {history: true/false, interval: true/false, aggregator: true/false, stream: RTCRtpSender|RTCRtpReceiver, filter: RTCRtpSender|RTCRtpReceiver, media: RTCPeerConnection events: true/false, id: true/false} // if filter is set do not set stream
   * if using filter or stream, media must also exist
   */
  constructor(attrs, options, optionalCreateOptions) {
    super({}, options);
    this.attrs = attrs;
    this.options = options;
    // what this stats object is configured to work with
    this.peerConnection = null;
    this.RTCRtpDirection = null;
    // usable values
    this.history = null;
    this.interval = null;
    this.aggregator = null;
    this.analyzer = null;
    this.stream = null;
    this.filter = null;
    this.events = null;
    this.id = null;
    this.populate(optionalCreateOptions);
  }

  populate(optionalCreateOptions) {
    if (optionalCreateOptions) {
      if (optionalCreateOptions.history) {
        this.withHistory();
      }
      if (optionalCreateOptions.interval) {
        this.withInterval();
      }
      if (optionalCreateOptions.aggregator) {
        this.withAggregator();
      }
      if (optionalCreateOptions.analyzer) {
        this.withAnalyzer(optionalCreateOptions);
      }
      if (optionalCreateOptions.filter && !optionalCreateOptions.stream && optionalCreateOptions.media) {
        this.withFilter(optionalCreateOptions.filter, optionalCreateOptions.media);
      }
      if (optionalCreateOptions.stream && !optionalCreateOptions.filter && optionalCreateOptions.media) {
        this.withStream(optionalCreateOptions.stream, optionalCreateOptions.media);
      }
      if (optionalCreateOptions.id) {
        this.withId(optionalCreateOptions.id);
      }
      if (optionalCreateOptions.onClose) {
        if (!isFunction(optionalCreateOptions.onClose)) {
          throw new Error('stats->populate#onClose must be a callback function for filtered data.');
        }
        this.onClose(optionalCreateOptions.onClose);
      }
      if (optionalCreateOptions.onEvent) {
        if (!isFunction(optionalCreateOptions.onEvent)) {
          throw new Error('stats->populate#onEvent must be a callback function for filtered data.');
        }
        this.withEvents();
        this.onEvent(optionalCreateOptions.onEvent);
      }
      if (optionalCreateOptions.onData) {
        if (!isFunction(optionalCreateOptions.onData)) {
          throw new Error('stats->populate#onData must be a callback function for filtered data.');
        }
        this.onData(optionalCreateOptions.onData);
      }
    }

    return this;
  }

  /**
   * @param {WebRTCData} data
   * @returns {undefined}
   */
  doHistory(data) {
    if (this.history) {
      this.history.add(data);
    }
  }

  /**
   * @param {WebRTCData} data
   * @returns {undefined}
   */
  doEvents(data) {
    if (this.events) {
      this.events.event(data);
    }
  }

  /**
   * @param {WebRTCData} data
   * @returns {undefined}
   */
  doAnalysis(data) {
    if (this.analyzer) {
      this.analyzer.analyze(data);
    }
  }

  /**
   * does all the work for the built properties
   * calls back a function with data from piped stream filter
   * @param {Function} cbFn
   * @returns {undefined}
   * @throws {Error} if the filter stream does not exist
   */
  onData(cbFn) {
    if (!this.filter) {
      throw new Error('The stats sender/receiver filter must be set up before data can be processed.');
    }
    this.filter.on(STATS.DATA, (filtered) => {
      this.doHistory(filtered);
      this.doEvents(filtered);
      this.doAnalysis(filtered);
      if (isFunction(cbFn)) {
        cbFn(filtered);
      }
    });

    return this;
  }

  onClose(cbFn) {
    if (!this.filter) {
      throw new Error('the stats sender/receiver filter must be set up before data can be closed.');
    }
    this.stream.on(STATS.END, (err) => {
      if (!err) {
        err = new Error(`The stats stream for id: ${this.id} ended.`);
      }
      cbFn(err);
    });

    return this;
  }

  onEvent(cbFn) {
    const events = this.getEvents();

    if (events) {
      events.on(EVENTS.STATS_UPDATE, (payload) => {
        cbFn(payload);
      });
    }

    return this;
  }

  /**
   * constructs an event object on this instance
   * @returns {MeetingStats}
   */
  withEvents() {
    const events = new StatsEvents();

    this.setEvents(events);

    return this;
  }

  /**
   * constructs a history object on this instance
   * @returns {MeetingStats}
   */
  withHistory() {
    const history = new StatsHistory(this.config.stats.historyMax);

    this.setHistory(history);

    return this;
  }

  /**
   * constructs a aggregator object on this instance
   * @returns {MeetingStats}
   */
  withAggregator() {
    const aggregator = new StatsAggregator();

    this.setAggregator(aggregator);

    return this;
  }

  /**
   * constructs a interval object on this instance
   * @returns {MeetingStats}
   */
  withInterval() {
    const interval = new StatsInterval();

    this.setInterval(interval);

    return this;
  }

  /**
   * constructs a analyzer object on this instance
   * @param {Object} createOptions
   * @returns {MeetingStats}
   */
  withAnalyzer(createOptions) {
    let analyzerOptions;

    if (isBoolean(createOptions.analyzer)) {
      analyzerOptions = this.config.stats.analyzer[createOptions.type];
    }

    const analyzer = new StatsAnalyzer(analyzerOptions || createOptions.analyzer);

    this.setAnalyzer(analyzer);

    return this;
  }


  withStream(transceiverDirection, peerConnection) {
    const stream = new StatsStream({
      rTCRtpDirection: transceiverDirection,
      peerConnection,
      interval: this.config.stats.interval
    });

    this.setStream(stream);

    return this;
  }

  withFilter(transceiverDirection, peerConnection) {
    this.withStream(transceiverDirection, peerConnection);
    this.setFilter(new StatsFilter());
    this.getStream().pipe(this.getFilter());

    return this;
  }

  /**
   * constructs an id to match this stats object
   * takes params as precedence
   * @param {String} id
   * @returns {MeetingStats}
   */
  withId(id) {
    if (id) {
      this.setId(id);
    }
    else {
      this.setId(uuid.v4());
    }

    return this;
  }

  /**
   * @returns {MeetingStats}
   */
  build() {
    return this;
  }

  /**
   * @param {String} id
   * @returns {undefined}
   */
  setId(id) {
    this.id = id;
  }

  /**
   * @param {StatsHistory} history
   * @returns {undefined}
   */
  setHistory(history) {
    this.history = history;
  }

  /**
   * @param {StatsAnalyzer} analyzer
   * @returns {undefined}
   */
  setAnalyzer(analyzer) {
    this.analyzer = analyzer;
  }

  /**
   * @param {StatsInterval} interval
   * @returns {undefined}
   */
  setInterval(interval) {
    this.interval = interval;
  }

  /**
   * @param {StatsAggregator} aggregator
   * @returns {undefined}
   */
  setAggregator(aggregator) {
    this.aggregator = aggregator;
  }

  /**
   * @param {StatsEvent} events
   * @returns {undefined}
   */
  setEvents(events) {
    this.events = events;
  }

  /**
   * @param {Readable} stream
   * @returns {undefined}
   */
  setStream(stream) {
    this.stream = stream;
  }

  /**
   * @param {Transform} filter
   * @returns {undefined}
   */
  setFilter(filter) {
    this.filter = filter;
  }

  /**
   * @returns {String}
   */
  getId() {
    return this.id;
  }

  /**
   * @returns {StatsHistory}
   */
  getHistory() {
    return this.history;
  }

  /**
   * @returns {StatsAnalyzer}
   */
  getAnalyzer() {
    return this.analyzer;
  }

  /**
   * @returns {StatsInterval}
   */
  getInterval() {
    return this.interval;
  }

  /**
   * @returns {StatsAggregator}
   */
  getAggregator() {
    return this.aggregator;
  }

  /**
   * @returns {StatsEvents}
   */
  getEvents() {
    return this.events;
  }

  /**
   * @returns {Readable}
   */
  getStream() {
    return this.stream;
  }

  /**
   * @returns {Transform}
   */
  getFilter() {
    return this.filter;
  }
}

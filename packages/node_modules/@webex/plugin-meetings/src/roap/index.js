import {StatelessSparkPlugin} from '@ciscospark/spark-core';

import {ROAP, EVENTS} from '../constants';
import MeetingCollection from '../meetings/collection';
import Events from '../events';

import RoapHandler from './handler';
import RoapRequest from './request';
/**
 * @class Roap
 */
export default class Roap extends StatelessSparkPlugin {
  /**
   *
   * @param {Object} attrs
   * @param {Object} options
   */
  constructor(attrs, options) {
    super({}, options);

    this.roapHandler = new RoapHandler({}, options);
    this.roapRequest = new RoapRequest({}, options);

    Events.on(EVENTS.ROAP_OK, this.sendRoapOK.bind(this));
    Events.on(EVENTS.ROAP_ANSWER, this.sendRoapAnswer.bind(this));
  }

  /**
   * Starts listening to mercury events for Roap messages
   * @returns {Promise}
   */
  start() {
    return Promise.resolve().then(() => {
      this.spark.internal.mercury.on(ROAP.ROAP_MERCURY, (result) => {
        const msg = result.data.message;
        const {correlationId} = result.data;
        this.logger.info(`Call-Mercury->-App: receives Roap Message [${JSON.stringify(msg, null, 2)}]`);
        this.roapHandler.submit({
          type: ROAP.RECEIVE_ROAP_MSG,
          msg,
          correlationId
        });
      });
    });
  }

  /**
   *
   * @param {String} correlationId correlation id of a meeting
   * @param {Number} seq ROAP sequence number
   * @returns {Promise}
   */
  stop(correlationId, seq) {
    this.spark.internal.mercury.off(ROAP.ROAP_MERCURY);

    this.roapHandler.submit({
      type: ROAP.RECEIVE_CALL_LEAVE,
      seq,
      correlationId
    });

    return Promise.resolve();
  }

  /**
   *
   * @param {Object} options
   * @returns {null}
   */
  sendRoapOK(options) {
    return Promise.resolve().then(() => {
      const meeting = MeetingCollection.get(options.correlationId);

      const roapMessage = {
        messageType: ROAP.ROAP_TYPES.OK,
        version: ROAP.ROAP_VERSION,
        seq: options.seq
      };

      return this.roapRequest
        .sendRoap({
          roapMessage,
          locusId: options.locusId,
          locusSelfId: options.locusSelfId,
          mediaId: options.mediaId,
          correlationId: options.correlationId,
          audioMuted: meeting.isAudioMuted(),
          videoMuted: meeting.isVideoMuted()
        })
        .then(() => {
          this.roapHandler.submit({
            type: ROAP.SEND_ROAP_MSG,
            msg: roapMessage,
            correlationId: options.correlationId
          });

          meeting.setRoapSeq(options.seq);
        });
    });
  }

  // eslint-disable-next-line no-warning-comments
  // TODO: try to merge sendRoapOk and roapAnswer
  /**
   * Sends a ROAP answer...
   * @param {Object} options
   * @returns {Promise}
   */
  sendRoapAnswer(options) {
    const meeting = MeetingCollection.get(options.correlationId);
    const roapMessage = {
      messageType: ROAP.ROAP_TYPES.ANSWER,
      sdps: options.sdps,
      version: ROAP.ROAP_VERSION,
      seq: options.roapSeq
    };

    return this.roapRequest
      .sendRoap({
        roapMessage,
        locusId: options.locusId,
        locusSelfId: options.locusSelfId,
        mediaId: options.mediaId,
        correlationId: options.correlationId,
        audioMuted: options.audioMuted,
        videoMuted: options.videoMuted
      })
      .then(() => {
        meeting.setRoapSeq(options.seq);
        this.roapHandler.submit({
          type: ROAP.SEND_ROAP_MSG,
          msg: roapMessage,
          correlationId: options.correlationId
        });
      });
  }

  /**
   * Sends a ROAP error...
   * @param {Object} session
   * @param {Object} locus
   * @param {String} errorType
   * @returns {Promise}
   */
  sendRoapError(session, locus, errorType) {
    const msg = {
      messageType: ROAP.ROAP_TYPES.ERROR,
      version: ROAP.ROAP_VERSION,
      errorType,
      seq: session.OFFER.seq
    };

    return this.roapRequest.sendRoap(msg, locus);
  }

  /**
   * sends a roap media request
   * @param {Object} options
   * @returns {Promise}
   */
  sendRoapMediaRequest(options) {
    const {meeting} = options;
    const roapMessage = {
      messageType: ROAP.ROAP_TYPES.OFFER,
      sdps: options.sdps,
      version: ROAP.ROAP_VERSION,
      seq: typeof options.roapSeq !== 'number' && Number.isNaN(parseFloat(options.roapSeq)) ? 0 : options.roapSeq + 1,
      tieBreaker: 4294967294 // Math.floor(Math.random() * (2 ** 32) - 1) // TODO: Handle the roap  conflict scenario
    };

    this.roapHandler.submit({
      type: ROAP.SEND_ROAP_MSG,
      msg: roapMessage,
      correlationId: meeting.correlationId
    });

    return this.roapRequest
      .sendRoap({
        roapMessage,
        correlationId: meeting.correlationId,
        locusId: meeting.locusId,
        locusSelfId: meeting.selfId, // locusSelfId ???
        mediaId: meeting.mediaId,
        audioMuted: meeting.isAudioMuted(),
        videoMuted: meeting.isVideoMuted()
      })
      .then((locus) => {
        this.roapHandler.submit({
          type: ROAP.SEND_ROAP_MSG_SUCCESS,
          seq: roapMessage.seq,
          correlationId: meeting.correlationId
        });
        meeting.setRoapSeq(roapMessage.seq);
        // eslint-disable-next-line no-warning-comments
        // TODO: we need to attach peerconenction to locus not sure if we need to pass everything here
        return locus;
        // eslint-disable-next-line no-warning-comments
        // TODO: check where to update the sequence number
      });
  }
}

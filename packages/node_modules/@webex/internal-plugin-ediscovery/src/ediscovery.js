/* eslint-disable prefer-template */
/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */
import {InvalidEmailAddressError} from './ediscovery-error';
import {requestWithRetries} from './retry';
import {waitForValue, WebexPlugin} from '@webex/webex-core';
import {oneFlight, base64} from '@webex/common';

import Map from 'babel-runtime/core-js/map';

/**
 * @class EDiscovery is used by compliance officers to run compliance reports
 *
 */
const EDiscovery = WebexPlugin.extend({
  namespace: 'EDiscovery',

  session: {
    contentSummaryCache: {
      type: 'object',
      default() {
        return new Map();
      }
    }
  },

  @waitForValue('@')
  /**
   * Creates a compliance report with a specific set of search parameters
   * @param {Object} reportRequest - A set of criteria for determining the focus of the search
   * @returns {Promise<ResponseEntity>} Http response containing the new report record
   */
  createReport(reportRequest) {
    if (!reportRequest) {
      throw Error('Undefined parameter');
    }

    const body = reportRequest;

    return this.request({
      method: 'POST',
      service: 'ediscovery',
      resource: 'reports',
      body
    });
  },

  @waitForValue('@')
  /**
   * Retrieves information relating to a specified report
   * @param {UUID} reportId - Id of the report being requested
   * @returns {Promise<ResponseEntity<ReportRecord>>} Http response containing the specified report record
   */
  getReport(reportId) {
    if (!reportId) {
      throw Error('Undefined parameter');
    }

    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: `reports/${reportId}`
    });
  },

  @waitForValue('@')
  /**
   * Retrieves all the compliance officers reports
   * @param {int} offset - Start position from which to retrieve records
   * @param {int} size - Number of records to retrieve
   * @returns {Promise<ResponseEntity<Array<ReportRecord>>>} Http Response containing a list of report records
   */
  getReports({offset, size}) {
    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: 'reports',
      qs: {offset, size}
    });
  },

  @waitForValue('@')
  /**
   * Deletes a specified report
   * @param {UUID} reportId - Id of the report being requested for deletion
   * @returns {Promise<ResponseEntity>} HttpResponse indicating if delete was successful
   */
  deleteReport(reportId) {
    if (!reportId) {
      throw Error('Undefined parameter');
    }

    return this.request({
      method: 'DELETE',
      service: 'ediscovery',
      resource: `reports/${reportId}`
    });
  },

  @waitForValue('@')
  /**
   * Restarts a completed or cancelled report so that it begins again from scratch
   * @param {UUID} reportId - Id of the report being requested
   * @returns {Promise<ResponseEntity<ReportRecord>>} Http response containing the report record
   */
  restartReport(reportId) {
    if (!reportId) {
      throw Error('Undefined parameter');
    }

    return this.request({
      method: 'PUT',
      service: 'ediscovery',
      resource: `reports/${reportId}`
    });
  },

  @waitForValue('@')
  /**
   * Retrieves content associated with a report
   * @param {UUID} reportId - Id of the report which contains the content
   * @param {UUID} offset - Start position from which to retrieve content
   * @param {UUID} size - Number of activities to retrieve
   * @returns {Promise<ResponseEntity<[Activity]>>} Http response containing the activities
   */
  getContent(reportId, {offset, size}) {
    if (!reportId) {
      throw Error('Undefined parameter');
    }
    const promises = [];

    // The content summary for a report is needed in order to decrypt the content for that report
    // Since retrieving it from the service every time it is needed is extremely inefficient,
    // we ensure that is is cached here before proceeding to get the report contents
    if (!this.contentSummaryCache.has(reportId)) {
      promises.push(this.getContentSummary(reportId));
    }

    return Promise.all(promises)
      .then(() => this.request({
        method: 'GET',
        service: 'ediscovery',
        resource: `reports/${reportId}/contents`,
        qs: {offset, size}
      }));
  },

  @waitForValue('@')
  @oneFlight({keyFactory: ({reportId}) => `${reportId}`})
  /**
   * Retrieves a list of the conversations relevant to a specified report
   * @param {UUID} reportId - Id of the report being requested
   * @param {boolean} writeToCache - Can be set to true if the content summary is expected to be accessed very frequently for space information
   * @returns {Promise<ResponseEntity<ContentSummary>>} Http response containing the content summary
   */
  getContentSummary(reportId) {
    if (!reportId) {
      throw Error('Undefined parameter');
    }

    let offset = 0;
    const size = 100;
    let contentSummary = [];

    // If the content summary for this report has already been cached then it can be retrieved from there instead of making a network call to ediscovery
    if (this.contentSummaryCache.has(reportId) && this.contentSummaryCache.get(reportId).size > 0) {
      return Array.from(this.contentSummaryCache.get(reportId).values());
    }

    function getNextContentSummaryPage(plugin) {
      return plugin.request({
        method: 'GET',
        service: 'ediscovery',
        resource: `reports/${reportId}/contents/summary`,
        qs: {offset, size}
      })
        .then((res) => {
          // The results are written to the contentSummaryCache as information for a space is likely to be accessed very frequently for decryption
          if (!plugin.contentSummaryCache.has(reportId)) {
            plugin.contentSummaryCache.set(reportId, new Map());
          }
          for (let i = 0; i < res.body.length; i += 1) {
            plugin.contentSummaryCache.get(reportId).set(res.body[i].spaceId, res.body[i]);
          }

          contentSummary = contentSummary.concat(res.body);
          if (res.body.length < size) {
            return contentSummary;
          }
          offset += size;

          return getNextContentSummaryPage(plugin);
        });
    }

    return getNextContentSummaryPage(this);
  },

  @waitForValue('@')
  /**
   * Retrieves information for a specific conversation relevant to a specified report
   * @param {UUID} reportId - Id of the report which contains the relevant content summary
   * @param {UUID} spaceId = Id of the conversation being requested
   * @returns {Promise<ResponseEntity<ContentSummary>>} Http response containing the specified content summary
   */
  getContentSummaryBySpaceId(reportId, spaceId) {
    if (!reportId || !spaceId) {
      throw Error('Undefined parameter(s)');
    }

    // If the content summary for this report has already been cached then it can be retrieved from there instead of making a network call to ediscovery
    if (this.contentSummaryCache.has(reportId) && this.contentSummaryCache.get(reportId).has(spaceId)) {
      return this.contentSummaryCache.get(reportId).get(spaceId);
    }

    return this.request({
      method: 'GET',
      service: 'ediscovery',
      resource: `reports/${reportId}/contents/summary/${spaceId}`
    })
      .then((res) => res.body);
  },

  @waitForValue('@')
  /**
   * Retrieves user information from CI based on a query filter
   * @param {UUID} orgId - Id of the organisation for which users are being requested
   * @param {String} filter - Query containing information to match users on (id, username, displayName etc.)
   * @returns {Promise<ResponseEntity<Resources>>} Http response containing the user information
   */
  getUsers(orgId, filter = '') {
    if (!orgId) {
      throw Error('Organisation Id is required in order to retrieve users');
    }

    return this.request({
      method: 'GET',
      service: 'hydra',
      resource: `scim/${orgId}/Users?filter=${filter}`
    });
  },

  @waitForValue('@')
  /**
   * Converts an array of email addresses to their corresponding user ids in CI
   * @param {Array<String>} emails - Array of email addresses
   * @returns {Array<UUID>} User ids for the email addresses being requested
   */
  convertEmailsToUserIds(emails) {
    const userIds = [];

    if (!emails || emails.length <= 0) {
      return userIds;
    }

    if (emails.length > 500) {
      throw Error('The maximum number of emails that can be converted is 500');
    }

    let orgId = '';

    // find the org id for the compliance officer, as this is required for the SCIM request
    return this.webex.people.get('me')
      .then((res) => {
        // Org id is base64 encoded and of the format Y2lzY29zcGFyazovL3VzL1BFT1BMRS81ZDU5Yjc5NS02ZmEyLTQ2NTQtOGVjMi03NjlkYjE1YzBkOWU
        const decodedOrgId = base64.decode(res.orgId);

        // Decode and strip out the uuid ciscospark://us/ORGANIZATION/8ceb2dbf-7a2c-41bf-91bb-a42a37d69b74
        orgId = decodedOrgId.substring(decodedOrgId.lastIndexOf('/') + 1, decodedOrgId.length);
      })
      .then(() => {
        if (!orgId) {
          throw Error('Cannot find org id for user');
        }

        const promises = [];
        const maxFilterEmails = 50;
        const validUserNames = [];

        // the hydra SCIM request can have a maximum of 50 filter arguments, so we may have to make multiple requests
        for (let i = 0; i < emails.length; i += maxFilterEmails) {
          // build query filter containing no more than 50 emails
          const emailBatch = emails.slice(i, i + maxFilterEmails);
          let filter = '';

          for (const email of emailBatch) {
            filter += `userName eq "${email}" or `;
          }
          // remove trailing ' or '
          filter = filter.slice(0, -4);

          // certain characters must first be encoded for the request to work successfully
          filter = encodeURIComponent(filter);

          const promise = requestWithRetries(this, this.getUsers, [orgId, filter])
            .then((res) => {
              for (const resource of res.body.Resources) {
                // User id is base64 encoded and of the format Y2lzY29zcGFyazovL3VzL1BFT1BMRS81ZDU5Yjc5NS02ZmEyLTQ2NTQtOGVjMi03NjlkYjE1YzBkOWU
                const decodedUserId = base64.decode(resource.id);

                // Decode and strip out the uuid ciscospark://us/PEOPLE/5d59b795-6fa2-4654-8ec2-769db15c0d9e
                userIds.push(decodedUserId.substring(decodedUserId.lastIndexOf('/') + 1, decodedUserId.length));

                // compile a list of usernames that were successfully converted to uuids
                // we will cross check this with the original list of emails to ensure no errors occurred
                validUserNames.push(resource.userName);
              }
            });

          promises.push(promise);
        }

        return Promise.all(promises)
          .then(() => {
            if (emails.length !== validUserNames.length) {
              // if user ids could not be found for any emails we assume they were invalid and throw a custom error
              const invalidEmails = emails.filter((email) => !validUserNames.includes(email));

              return Promise.reject(new InvalidEmailAddressError(invalidEmails));
            }

            return userIds;
          });
      });
  }

});

export default EDiscovery;
